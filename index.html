<!DOCTYPE html>
<html>
<head>
    <meta http-equiv='content-type' content='text/html;charset=utf-8'/>
    <title>Sprawl</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            margin: 0;
            padding: 0;
        }
    </style>
</head>

<body>
<canvas width="1900" height="960"></canvas>

<script>
"use strict";

var tileWidth = 130;
var tileHeight = 66;

function getMousePosition(e) {
    var canvasBounds = e.target.getBoundingClientRect();
    var screenX = e.clientX - canvasBounds.left;
    var screenY = e.clientY - canvasBounds.top;
    return {x: screenX, y: screenY};
}

function Cell(owner) {
    this.owner = owner;
    this.neighbors = [];
    this.detail = (Math.random() * 10)|0;
}

Cell.prototype.flood = function(callback, visited) {
    if (!callback(this)) {
        return;
    }

    if (visited === undefined) {
        visited = [];
    }
    visited.push(this);
    for (var i = 0; i < this.neighbors.length; i++) {
        var cell = this.neighbors[i];
        if (visited.indexOf(cell) === -1) {
            cell.flood(callback, visited);
        }
    }
}

Cell.prototype.liberties = function() {
    var count = 0;
    var owner = this.owner;
    this.flood(function(c) {
        if (c.owner === 0) {
            count += 1
        }
        return c.owner === owner;
    });
    return count;
}

Cell.prototype.kill = function() {
    var owner = this.owner;
    this.flood(function(c) {
        if (c.owner === owner) {
            c.owner = 0;
            return true;
        }
    });
}

function Board(side, canvasWidth, canvasHeight) {
    this.side = side;
    this.map = [];
    for (var i = 0; i < side; i++) {
        var line = [];
        this.map.push(line);
        for (var j = 0; j < side; j++) {
            line.push(new Cell(0));
        }
    }

    for (var y = 0; y < side; y++) {
        for (var x = 0; x < side; x++) {
            var neighbors = [
                this.get(x, y+1),
                this.get(x, y-1),
                this.get(x+1, y),
                this.get(x-1, y),
            ].filter(function(e) {
                return e !== undefined;
            });
            this.get(x, y).neighbors = neighbors;
        }
    }

    this.canvas = document.createElement('canvas');
    this.canvas.width = canvasWidth;
    this.canvas.height = canvasHeight;
    this.buffer = this.canvas.getContext('2d');
}

Board.prototype.get = function(x, y, defaultValue) {
    if (x >= 0 && x < this.side && y >= 0 && y < this.side) {
        return this.map[y][x];
    } else {
        return defaultValue;
    }
};

Board.prototype.playAt = function(player, x, y) {
    var cell = this.get(x, y, new Cell(-1));
    if (cell.owner !== 0) {
        return false;
    }

    cell.owner = player;

    var self = this;
    cell.neighbors.forEach(function(c) {
        if (c.liberties() === 0) {
            c.kill();
        }
    });

    if (cell.liberties() > 0) {
        return true;
    } else {
        cell.owner = 0;
        return false;
    }
};

Board.prototype.render = function(width, height, scale, tiles) {
    this.buffer.save();
    this.canvas.width = width;
    this.canvas.height = height;
    this.buffer.fillStyle = '#EEE';
    this.buffer.fillRect(0, 0, width, height);

    this.buffer.translate(width/2, height/2);
    this.buffer.scale(scale, scale);

    for (var y = 0; y < this.side; y++) {
        for (var x = this.side - 1; x >= 0; x--) {
            var cell = this.map[y][x];

            var screenX = (y+x-this.side)*tileWidth/2;
            var screenY = (y-x)*tileHeight/2;

            if (cell.owner === 0) {
                switch (cell.detail) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        tile = tiles.ground;
                        break
                    case 6:
                        tile = tiles.trees_5;
                        break;
                    case 7:
                        tile = tiles.trees_6;
                        break;
                    case 8:
                        tile = tiles.trees_8;
                        break;
                    case 9:
                        tile = tiles.trees_9;
                        break;
                }
                this.buffer.drawImage(tile, screenX, screenY-tile.height);
            } else {
                this.buffer.drawImage(tiles.ground, screenX, screenY-tiles.ground.height);
                var tile = tiles['owner_' + cell.owner];
                this.buffer.drawImage(tile, screenX + tiles.ground.width/2 - tile.width/2, screenY-tile.height*1.5);
            }
        }
    }

    this.buffer.restore();
}

function Game(side, context, width, height) {
    this.width = width;
    this.height = height;
    this.context = context;
    this.board = new Board(side, this.width, this.height);
    this.player = 1;
    this.updateScale();
    this.loadTiles(this.update.bind(this));
    this.dragging = 0;
}

Game.prototype.updateScale = function() {
    var side = this.board.side;
    this.scale = Math.min(this.width / (side * tileWidth), this.height / ((side+1) * tileHeight)) * 0.9;
}

Game.prototype.loadTiles = function(callback) {
    var tileTypes = ['ground', 'owner_1', 'owner_2', 'trees_1', 'trees_2', 'trees_3', 'trees_4', 'trees_5', 'trees_6', 'trees_7', 'trees_8', 'trees_9'];
    this.tiles = {};

    var remaining = tileTypes.length;
    for (var i = 0; i < remaining; i++) {
        var tile = new Image();
        tile.onload = function() {
            remaining--;
            if (remaining === 0) {
                callback();
            }
        };
        tile.onerror = function(e) {
            console.log(e);
        }
        var type = tileTypes[i]
        tile.src = type + '.png';
        this.tiles[type] = tile;
    }
}

Game.prototype.update = function() {
    this.board.render(this.width, this.height, this.scale, this.tiles);
    this.render();
}

Game.prototype.render = function() {
    this.context.clearRect(0, 0, this.width, this.height);

    var image = this.board.buffer.getImageData(0, 0, this.width, this.height);
    this.context.putImageData(image, 0, 0);

    if (this.dragging != 1) {
        var tile = this.tiles.owner_1;
        this.context.drawImage(tile, 200-tile.width/2, this.height-200);
    }
    if (this.dragging != 2) {
        var tile = this.tiles.owner_2;
        this.context.drawImage(tile, this.width-200-tile.width/2, this.height-200);
    }
}

Game.prototype.playEvent = function(e) {
    var pos = getMousePosition(e);
    var tempX = (pos.x - this.width/2) / this.scale / tileWidth - 0.5;
    var tempY = (pos.y - this.height/2) / this.scale / tileHeight + 1;
    var mapX = Math.round(tempX - tempY + this.board.side/2);
    var mapY = Math.round(tempX + tempY + this.board.side/2);
    var ok = this.board.playAt(this.player, mapX, mapY);
    if (ok) {
        this.player = this.player === 1 ? 2 : 1;
    }
}

Game.prototype.hookEvents = function(canvas, autoresize) {
    //canvas.onclick = game.playEvent.bind(game);

    canvas.onmousedown = (function(e) {
        this.dragging = getMousePosition(e).x < this.width/2 ? 1 : 2;
        this.render();
        canvas.onmousemove = (function(e) {
            this.render();
            var pos = getMousePosition(e);
            this.context.save();
            //this.context.translate(this.width/2, this.height/2-tileHeight/2)
            this.context.scale(this.scale, this.scale);
            var tile = this.tiles['owner_' + this.dragging]
            this.context.drawImage(tile, pos.x/this.scale-tile.height/2, pos.y/this.scale-tile.width/1.7);
            this.context.restore();
        }).bind(this);
        canvas.onmousemove(e);
    }).bind(this);

    canvas.onmouseup = (function(e) {
        this.player = this.dragging;
        this.dragging = 0;
        canvas.onmousemove = undefined;
        game.playEvent(e);
        this.update();
    }).bind(this);

    if (autoresize) {
        window.onresize = (function() {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            this.updateScale();
            this.update();
        }).bind(this);
        window.onresize();
    }
}

var canvas = document.getElementsByTagName('canvas')[0];
var game = new Game(19, canvas.getContext('2d'), canvas.width, canvas.height);
game.hookEvents(canvas, true);

</script>
</body>
</html>
