<!DOCTYPE html>
<html>
<head>
    <meta http-equiv='content-type' content='text/html;charset=utf-8'/>
    <title>Sprawl</title>
</head>

<body>
<canvas width="1900" height="960" style="background-color: #EEE;" ></canvas>

<script>
"use strict";

var scale = 0.7;

var tileWidth = 130;
var tileHeight = 66;

function getMousePosition(e) {
    var canvasBounds = e.target.getBoundingClientRect();
    var screenX = e.clientX - canvasBounds.left;
    var screenY = e.clientY - canvasBounds.top;
    return {x: screenX, y: screenY};
}

function Cell(owner) {
    this.owner = owner;
    this.neighbors = [];
}

Cell.prototype.flood = function(callback, visited) {
    if (!callback(this)) {
        return;
    }

    if (visited === undefined) {
        visited = [];
    }
    visited.push(this);
    for (var i = 0; i < this.neighbors.length; i++) {
        var cell = this.neighbors[i];
        if (visited.indexOf(cell) === -1) {
            cell.flood(callback, visited);
        }
    }
}

Cell.prototype.liberties = function() {
    var count = 0;
    var owner = this.owner;
    this.flood(function(c) {
        if (c.owner === 0) {
            count += 1
        }
        return c.owner === owner;
    });
    return count;
}

Cell.prototype.kill = function() {
    var owner = this.owner;
    this.flood(function(c) {
        if (c.owner === owner) {
            c.owner = 0;
            return true;
        }
    });
}

function Board(side, canvasWidth, canvasHeight) {
    this.side = side;
    this.map = [];
    for (var i = 0; i < side; i++) {
        var line = [];
        this.map.push(line);
        for (var j = 0; j < side; j++) {
            line.push(new Cell(0));
        }
    }

    for (var y = 0; y < side; y++) {
        for (var x = 0; x < side; x++) {
            var neighbors = [
                this.get(x, y+1),
                this.get(x, y-1),
                this.get(x+1, y),
                this.get(x-1, y),
            ].filter(function(e) {
                return e !== undefined;
            });
            this.get(x, y).neighbors = neighbors;
        }
    }

    var canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    this.buffer = canvas.getContext('2d');
}

Board.prototype.get = function(x, y, defaultValue) {
    if (x >= 0 && x < this.side && y >= 0 && y < this.side) {
        return this.map[y][x];
    } else {
        return defaultValue;
    }
};

Board.prototype.playAt = function(player, x, y) {
    var cell = this.get(x, y, new Cell(-1));
    if (cell.owner !== 0) {
        return false;
    }

    cell.owner = player;

    var self = this;
    cell.neighbors.forEach(function(c) {
        if (c.liberties() === 0) {
            c.kill();
        }
    });

    if (cell.liberties() > 0) {
        return true;
    } else {
        cell.owner = 0;
        return false;
    }
};

Board.prototype.render = function(width, height, tiles) {
    this.buffer.save();
    this.buffer.fillStyle = '#FFF';
    this.buffer.fillRect(0, 0, canvas.width, canvas.height);

    this.buffer.translate(canvas.width/2, canvas.height/2-tileHeight/2);
    this.buffer.scale(scale, scale);

    for (var y = 0; y < this.side; y++) {
        for (var x = this.side - 1; x >= 0; x--) {
            var owner = this.map[y][x].owner;
            var ground = tiles[0];
            //buffer.fillRect(x*tile.width, y*tile.height, 10, 10);
            var screenX = (y+x-this.side)*tileWidth/2;
            var screenY = (y-x)*tileHeight/2;
            this.buffer.drawImage(ground, screenX, screenY);

            if (owner > 0) {
                var tile = tiles[owner];
                this.buffer.drawImage(tile, screenX + ground.width/2 - tile.width/2, screenY - tileHeight / 2);
            }
        }
    }

    this.buffer.restore();
}

function Game(side, context, width, height) {
    this.width = width;
    this.height = height;
    this.context = context;
    this.board = new Board(side, this.width, this.height);
    this.player = 1;
    this.loadTiles(this.update.bind(this));
    this.dragging = 0;
}

Game.prototype.loadTiles = function(callback) {
    this.tiles = {};

    var remaining = 3
    for (var i = 0; i < remaining; i++) {
        var tile = new Image();
        tile.onload = function() {
            remaining--;
            if (remaining === 0) {
                callback();
            }
        };
        tile.onerror = function(e) {
            console.log(e);
        }
        tile.src = 'owner_' + i + '.png';
        this.tiles[i] = tile;
    }
}

Game.prototype.update = function() {
    this.board.render(this.width, this.height, this.tiles);
    this.render();
}

Game.prototype.render = function() {
    var image = this.board.buffer.getImageData(0, 0, this.width, this.height);
    this.context.putImageData(image, 0, 0);

    if (this.dragging != 1) {
        this.context.drawImage(this.tiles[1], 100, this.height-200);
    }
    if (this.dragging != 2) {
        this.context.drawImage(this.tiles[2], this.width-100, this.height-200);
    }
}

Game.prototype.playEvent = function(e) {
    var pos = getMousePosition(e);
    var screenX = (pos.x - this.width/2) / scale / tileWidth;
    var screenY = (pos.y - this.height/2) / scale / (tileHeight/2);
    var mapX = Math.round(screenX - screenY/2 + this.board.side/2 - 0.5);
    var mapY = Math.round(screenX + screenY/2 + this.board.side/2);
    var ok = this.board.playAt(this.player, mapX, mapY);
    if (ok) {
        this.player = this.player === 1 ? 2 : 1;
    }
}

Game.prototype.hookEvents = function(canvas) {
    //canvas.onclick = game.playEvent.bind(game);

    canvas.onmousedown = (function(e) {
        this.dragging = getMousePosition(e).x < this.width/2 ? 1 : 2;
        this.render();
        canvas.onmousemove = (function(e) {
            this.render();
            var pos = getMousePosition(e);
            this.context.save();
            //this.context.translate(this.width/2, this.height/2-tileHeight/2)
            this.context.scale(scale, scale);
            var tile = this.tiles[this.dragging]
            this.context.drawImage(tile, pos.x/scale-tile.height/2, pos.y/scale-tile.width/1.7);
            this.context.restore();
        }).bind(this);;
    }).bind(this);

    canvas.onmouseup = (function(e) {
        this.player = this.dragging;
        this.dragging = 0;
        canvas.onmousemove = undefined;
        game.playEvent(e);
        this.update();
    }).bind(this)
}

var canvas = document.getElementsByTagName('canvas')[0];
var game = new Game(19, canvas.getContext('2d'), canvas.width, canvas.height);
game.hookEvents(canvas);

</script>
</body>
</html>
